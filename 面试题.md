# 面试题

1. 判定()(())括号合法

解题思路: 将左括号入栈，当遇到右括号时候出栈

2. 链表拆分为2个链表

遍历链表拆成2个Slice[Node]，然后将Slice倒序，逐个拼接到Next指针之中

3. 栈实现队列

使用2个栈，队列元素直接推入A，读取B栈，当B栈空了的时候直接将A栈全部推入B栈

4. 用队列实现栈

使用一个队列，在取数据的时候将队尾之前的所有元素取出来push进去，那么原来队尾元素自然就变成了队头

5. 合并两个有序链表(转升序链)

1-2-4
1-3-4
1-1-2-3-4-4

链表有一个Node{data,*next}, 遍历的方式是 p = p.next 直到 p.next is null
链表追加的方式是 p = p.next 注意这一点非常巧妙，每一个next都会当成当前链表节点
而被替换上来的next也就是原来的 p.next.next 又会被继续替换


6. 链表的遍历和创建

```
package main

import (
	"fmt"
)

func main(){
	type Node struct {
		Data int
		Next *Node
	}
	IDList := []int{1, 2, 3}
    // 链必须是指针
	var nodeList *Node
	for _, v := range IDList {
		n := Node{
			Data: v,
			Next: nil,
		}
        // 将长链表追加到当前节点的Next
        // 当前节点作为链头
        // 再将当前节点链覆盖当前的链
		n.Next = nodeList
		nodeList = &n
	}
	for {
		fmt.Printf("nodeList=%d\n", nodeList.Data)
		if nodeList.Next == nil {
			break
		}
		nodeList = nodeList.Next
	}
}
```

